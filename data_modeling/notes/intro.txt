#####################
data modeling intro
#####################
organize elements of data and how they relate to one another
easily translate to database modeling = final state of the model

process to support business and user applications
- need to know how much stock sold 
- need to know about the user activity

data must be retained and served to the business or the end users
data must be stored and persisted and how it will relate to each other

conceptual data modeling
entity mapping
giant whiteboarding session to connect how the data is related to one another

logical data modeling
move conceptual > logical
using the concept of tables, schemas, and columns 

physical data modeling
transforming logical plan > DDL (data definition language)

data organization is critical
determines later data use
need to make sure queries are simple and straightforward
iterative process

#############################
relational databases
#############################
organize data into one more tables of columns and rows with a unique key ID each row
table aka relation
attribute aka column
tuple aka row
generally each table represents 1 entity type (ie customer or product)

database/schema = collection of tables
tables/relation = grouping of rows sharing the same labeled elements

when to use a relational database
ease of use with SQL
ability to use JOINS - combine more than one table based on a common key
ability to aggregations and analytics
smaller data volume
model the data itself - not modeling your data to the queries
secondary indexes - an index that is not the primary key
ACID transactions

ACID
guarantee validity even in the event of power failures, errors
Atomicity = the whole transaction is processed or nothing is processed 
ex: if transferring money from checking to savings account, both steps must be success or else no steps must occur

Consistency = only transactions that abide by constrains and rules is written into the database otherwise database keeps previous state
ex: cannot insert an integer for a field that requires a boolean

Isolation = transactions are processed independently and securely
the rows that are effected by the query are locked until the transaction is complete
other queries are not able to access these rows 
this ensures correctness of data for multiple users running queries against the database

https://www.lifewire.com/isolation-definition-1019173
all transactions are carried out as if it is the only transaction in the system
need to entirely complete one transaction before executing another transaction
ex: Joe issues a transaction on a database at the same time Mary issues a different transaction
both transactions should operate in an isolated  manner 
the database should perform Joe's entire transaction before executing Mary's or vice versa
this prevents Joe's transaction from reading intermediate data produced as side effects of Mary's transaction that will not be written to the db

Durability = completed transactions are saved to the database even in cases of system failure
guarantees once a transaction has been COMMITTED it will remain committed even in the case of a system failure
transaction is recorded in non-volatile memory (ie not in RAM)
ex: if you unplug a computer with a database and plug the computer back in, the data will be there

Postgres
requires you to commit after every transaction
set autocommit=True to avoid having to commit after every transaction

#############################
non-relational (NoSQL) databases
#############################
when not to use a relational database model
1. large amounts of data
relational db can only scale vertically = add more resources to a single machine = not distributed databases
you are limited by the amount of data you can store on one machine

2. need to store data in different data types formats
not designed to handle non-structured (ie JSON) data

3. need high thoroughput = fast reads
while ACID transactions add benefits, they slow down the process of reading and writing data

4. flexible schemas
allow columns to be added that do not have to be used by every row 
saving disk space bc in RDBMS nulls take up space

5. need high availability 
bc relational db are one one machine = single point of failure 
even if there is a rollover backup system, recovery takes time
a distributed system has higher availability 

6. need to scale horizonally
can add more machines to system to increase performance and space for data

high availability + horizonal scaling > evolution of NoSQL DB

NoSQL database
simpler design
simpler horizontal scaling
finer control of availability 
data structures used are different > make some operations faster

Common types of NoSQL databases
Apache Cassandra = Partition Row store

